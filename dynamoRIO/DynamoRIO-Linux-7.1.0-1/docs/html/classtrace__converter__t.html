<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: trace_converter_t&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtrace__converter__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">trace_converter_t&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;raw2trace.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5c55f92cdbe56e0a520de6e167005061"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a5c55f92cdbe56e0a520de6e167005061">trace_converter_t</a> (void *dcontext_in)</td></tr>
<tr class="separator:a5c55f92cdbe56e0a520de6e167005061"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba9855ba99747cb999afcf409bbab82"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#adba9855ba99747cb999afcf409bbab82">process_offline_entry</a> (void *tls, const offline_entry_t *in_entry, thread_id_t tid, OUT bool *end_of_record, OUT bool *last_bb_handled)</td></tr>
<tr class="separator:adba9855ba99747cb999afcf409bbab82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534c6ae391de423b84fe04c58768a9c4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a534c6ae391de423b84fe04c58768a9c4">read_header</a> (void *tls, OUT <a class="el" href="structtrace__header__t.html">trace_header_t</a> *header)</td></tr>
<tr class="separator:a534c6ae391de423b84fe04c58768a9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e17954bb3d6e42edc49531c980439d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; module_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#ac4e17954bb3d6e42edc49531c980439d">modvec</a> () const</td></tr>
<tr class="separator:ac4e17954bb3d6e42edc49531c980439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658fb239de4d87f44e7e21c1718cf634"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a658fb239de4d87f44e7e21c1718cf634">set_modvec</a> (const std::vector&lt; module_t &gt; *modvec_in)</td></tr>
<tr class="separator:a658fb239de4d87f44e7e21c1718cf634"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9b4bff847e3e572ab1424f784ad4dbac"><td class="memItemLeft" align="right" valign="top">void *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a9b4bff847e3e572ab1424f784ad4dbac">dcontext</a></td></tr>
<tr class="separator:a9b4bff847e3e572ab1424f784ad4dbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1bd6b969039316a9c1369d52b15f9c62"><td class="memItemLeft" align="right" valign="top">static const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtrace__converter__t.html#a1bd6b969039316a9c1369d52b15f9c62">WRITE_BUFFER_SIZE</a> = 64</td></tr>
<tr class="separator:a1bd6b969039316a9c1369d52b15f9c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class trace_converter_t&lt; T &gt;</h3>

<p><a class="el" href="classtrace__converter__t.html">trace_converter_t</a> is a reusable component that encapsulates raw trace conversion.</p>
<p>Conversion happens from a data source abstracted by the type parameter T. We make no assumption about how thread buffers are organized. We do assume the internal composition of thread buffers is "as written" by the thread. For example, all thread buffers belonging to different threads may be in a separate files; or buffers may be co-located in one large file, or spread accross multiple, mixed-thread files.</p>
<p><a class="el" href="classtrace__converter__t.html">trace_converter_t</a> expects to be instantiated with its type template T which should provide the following APIs. These pass through an opaque pointer which provides per-traced-thread-local data to the converter:</p>
<ul>
<li>
<p class="startli">const offline_entry_t *get_next_entry(void *tls)</p>
<p>Point to the next offline entry_t. There is no assumption about the underlying source of the data, and <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> will not attempt to dereference past the provided pointer.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void unread_last_entry(void *tls)</p>
<p>Ensure that the next call to get_next_entry() re-reads the last value.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">trace_entry_t *get_write_buffer(void *tls)</p>
<p>Return a writable buffer guaranteed to be at least <a class="el" href="classtrace__converter__t.html#a1bd6b969039316a9c1369d52b15f9c62">WRITE_BUFFER_SIZE</a> large. get_write_buffer() may reuse the same buffer after write() or write_delayed_branches() is called.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">bool write(void *tls, const trace_entry_t *start, const trace_entry_t *end)</p>
<p>Writes the converted traces between start and end, where end is past the last item to write. Both start and end are assumed to be pointers inside a buffer returned by get_write_buffer().</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">std::string write_delayed_branches(const trace_entry_t *start, const trace_entry_t *end)</p>
<p>Similar to write(), but treat the provided traces as delayed branches: if they are the last values in a record, they belong to the next record of the same thread.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">std::string on_thread_end(void *tls)</p>
<p>Callback notifying the currently-processed thread has exited. <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> extenders are expected to track record metadata themselves. <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> offers APIs for extracting that metadata.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void log(uint level, const char *fmt, ...)</p>
<p>Implementers are given the opportunity to implement their own logging. The level parameter represents severity: the lower the level, the higher the severity.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">const <a class="el" href="structinstr__summary__t.html">instr_summary_t</a> *get_instr_summary(void *tls, uint64 modidx, uint64 modoffs, INOUT app_pc *pc, app_pc orig)</p>
<p>Return the <a class="el" href="structinstr__summary__t.html">instr_summary_t</a> representation of the instruction at *pc, updating the value at pc to the PC of the next instruction. It is assumed the app binaries have already been loaded using <a class="el" href="classmodule__mapper__t.html">module_mapper_t</a>, and the values at *pc point within memory mapped by the module mapper. This API provides an opportunity to cache decoded instructions.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">void set_prev_instr_rep_string(void *tls, bool value)</p>
<p>Sets a per-traced-thread cached flag that is read by was_prev_instr_rep_string(). </p>
<p class="endli"></p>
</li>
<li>
<p class="startli">bool was_prev_instr_rep_string(void *tls)</p>
<p class="endli">Queries a per-traced-thread cached flag that is set by set_prev_instr_rep_string().  </p>
</li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5c55f92cdbe56e0a520de6e167005061"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c55f92cdbe56e0a520de6e167005061">&#9670;&nbsp;</a></span>trace_converter_t()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::<a class="el" href="classtrace__converter__t.html">trace_converter_t</a> </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dcontext_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a new <a class="el" href="classtrace__converter__t.html">trace_converter_t</a> object. If a nullptr dcontext_in is passed, creates a new DR context va <a class="el" href="dr__tools_8h.html#af63184f56cc0508e2840f64e84b1c48d">dr_standalone_init()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4e17954bb3d6e42edc49531c980439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e17954bb3d6e42edc49531c980439d">&#9670;&nbsp;</a></span>modvec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;module_t&gt;&amp; <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::modvec </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the module map. </p>

</div>
</div>
<a id="adba9855ba99747cb999afcf409bbab82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba9855ba99747cb999afcf409bbab82">&#9670;&nbsp;</a></span>process_offline_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::process_offline_entry </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const offline_entry_t *&#160;</td>
          <td class="paramname"><em>in_entry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">thread_id_t&#160;</td>
          <td class="paramname"><em>tid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>end_of_record</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>last_bb_handled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert starting from in_entry, and reading more entries as required. Sets end_of_record to true if processing hit the end of a record. <a class="el" href="classtrace__converter__t.html#a658fb239de4d87f44e7e21c1718cf634">set_modvec()</a> must have been called by the implementation before calling this API. </p>

</div>
</div>
<a id="a534c6ae391de423b84fe04c58768a9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534c6ae391de423b84fe04c58768a9c4">&#9670;&nbsp;</a></span>read_header()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::read_header </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="structtrace__header__t.html">trace_header_t</a> *&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the header of a thread, by calling T's get_next_entry() successively to populate the header values. The timestamp field is populated only for legacy traces. </p>

</div>
</div>
<a id="a658fb239de4d87f44e7e21c1718cf634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658fb239de4d87f44e7e21c1718cf634">&#9670;&nbsp;</a></span>set_modvec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::set_modvec </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; module_t &gt; *&#160;</td>
          <td class="paramname"><em>modvec_in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the module map. Must be called before <a class="el" href="classtrace__converter__t.html#adba9855ba99747cb999afcf409bbab82">process_offline_entry()</a> is called. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a9b4bff847e3e572ab1424f784ad4dbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4bff847e3e572ab1424f784ad4dbac">&#9670;&nbsp;</a></span>dcontext</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* const <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::dcontext</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The pointer to the DR context. </p>

</div>
</div>
<a id="a1bd6b969039316a9c1369d52b15f9c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd6b969039316a9c1369d52b15f9c62">&#9670;&nbsp;</a></span>WRITE_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint <a class="el" href="classtrace__converter__t.html">trace_converter_t</a>&lt; T &gt;::WRITE_BUFFER_SIZE = 64</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The trace_entry_t buffer returned by get_write_buffer() is assumed to be at least <a class="el" href="classtrace__converter__t.html#a1bd6b969039316a9c1369d52b15f9c62">WRITE_BUFFER_SIZE</a> large. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>drmemtrace/<a class="el" href="raw2trace_8h.html">raw2trace.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="classtrace__converter__t.html">trace_converter_t</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 7.1.0 --- Fri Feb 22 2019 14:52:31 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
